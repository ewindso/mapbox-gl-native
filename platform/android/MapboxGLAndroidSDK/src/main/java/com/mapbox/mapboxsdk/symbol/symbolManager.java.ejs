<%
  const type = locals.type;
  const properties = locals.properties;
  const doc = locals.doc;
-%>
// This file is generated. Edit android/platform/scripts/generate-style-code.js, then run `make android-style-code`.

package com.mapbox.mapboxsdk.symbol;

import android.graphics.PointF;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.UiThread;
import android.support.annotation.VisibleForTesting;
import android.support.v4.util.LongSparseArray;
import com.mapbox.geojson.Feature;
import com.mapbox.geojson.FeatureCollection;
import com.mapbox.mapboxsdk.geometry.LatLng;
import com.mapbox.mapboxsdk.maps.MapboxMap;
import com.mapbox.mapboxsdk.style.layers.PropertyValue;
import com.mapbox.mapboxsdk.style.layers.SymbolLayer;
import com.mapbox.mapboxsdk.style.sources.GeoJsonSource;

import java.util.ArrayList;
import java.util.List;

import static com.mapbox.mapboxsdk.style.expressions.Expression.get;
import static com.mapbox.mapboxsdk.style.layers.PropertyFactory.*;

/**
 * The symbol manager allows to add symbols to a map.
 */
public class SymbolManager {

  public static final String ID_GEOJSON_SOURCE = "mapbox-android-symbol-source";
  public static final String ID_GEOJSON_LAYER = "mapbox-android-symbol-layer";

  // map integration components
  private GeoJsonSource geoJsonSource;
  private SymbolLayer symbolLayer;

  // callback listeners
  private OnSymbolClickListener symbolClickListener;

  // internal data set
  private final LongSparseArray<Symbol> symbols = new LongSparseArray<>();
  private final List<Feature> features = new ArrayList<>();
  private long currentMarkerId;

  /**
   * Create a symbol manager, used to manage symbols.
   *
   * @param mapboxMap the map object to add symbols to
   */
  @UiThread
  public SymbolManager(@NonNull MapboxMap mapboxMap) {
    this(mapboxMap, new GeoJsonSource(ID_GEOJSON_SOURCE), new SymbolLayer(ID_GEOJSON_LAYER, ID_GEOJSON_SOURCE)
      .withProperties(
        getLayerDefinition()
      )
    );
  }

  /**
   * Create a symbol manager, used to manage symbols.
   *
   * @param mapboxMap     the map object to add symbols to
   * @param geoJsonSource the geojson source to add symbols to
   * @param symbolLayer   the sybol layer to visualise symbols with
   */
  @VisibleForTesting
  public SymbolManager(MapboxMap mapboxMap, @NonNull GeoJsonSource geoJsonSource, SymbolLayer symbolLayer) {
    this.geoJsonSource = geoJsonSource;
    this.symbolLayer = symbolLayer;
    mapboxMap.addSource(geoJsonSource);
    mapboxMap.addLayer(symbolLayer);
    mapboxMap.addOnMapClickListener(new MapClickResolver(mapboxMap));
  }

  /**
   * Create a symbol on the map from a LatLng coordinate.
   *
   * @param latLng place to layout the symbol on the map
   * @return the newly created symbol
   */
  @UiThread
  public Symbol createSymbol(@NonNull LatLng latLng) {
    Symbol symbol = new Symbol(this, currentMarkerId);
    symbol.setLatLng(latLng);
    symbols.put(currentMarkerId, symbol);
    currentMarkerId++;
    return symbol;
  }

  /**
   * Delete a symbol from the map.
   *
   * @param symbol to be deleted
   */
  @UiThread
  public void deleteSymbol(@NonNull Symbol symbol) {
    symbols.remove(symbol.getId());
    updateSource();
  }

  /**
   * Get a list of current symbols.
   *
   * @return list of symbols
   */
  @UiThread
  public LongSparseArray<Symbol> getSymbols() {
    return symbols;
  }

  /**
   * Trigger an update to the underlying source
   */
  public void updateSource() {
    // todo move feature creation to a background thread?
    features.clear();
    Symbol symbol;
    for (int i = 0; i < symbols.size(); i++) {
      symbol = symbols.valueAt(i);
      features.add(Feature.fromGeometry(symbol.getGeometry(), symbol.getFeature()));
    }
    geoJsonSource.setGeoJson(FeatureCollection.fromFeatures(features));
  }

  /**
   * Set a callback to be invoked when a symbol has been clicked.
   * <p>
   * To unset, use a null argument.
   * </p>
   *
   * @param symbolClickListener the callback to be invoked when a symbol is clicked, or null to unset
   */
  public void setOnSymbolClickListener(@Nullable OnSymbolClickListener symbolClickListener) {
    this.symbolClickListener = symbolClickListener;
  }

  private static PropertyValue<?>[] getLayerDefinition() {
    return new PropertyValue[]{
<% for (const property of properties) { -%>
<% if (supportsPropertyFunction(property)) { -%>
     <%- camelizeWithLeadingLowercase(property.name) %>(get("<%- property.name %>")),
<% } -%><% } -%>
    };
  }

  // Property accessors
<% for (const property of properties) { -%>
<% if (!supportsPropertyFunction(property)) { -%>
  /**
   * Get the <%- camelize(property.name) %> property
   *
   * @return property wrapper value around <%- propertyType(property) %>
   */
  public <%- propertyType(property) %> get<%- camelize(property.name) %>() {
    return symbolLayer.get<%- camelize(property.name) %>().value;
  }

  /**
   * Set the <%- camelize(property.name) %> property
   *
   * @param value property wrapper value around <%- propertyType(property) %>
   */
  public void set<%- camelize(property.name) %>(<%- propertyType(property) %> value) {
    symbolLayer.setProperties(<%- camelizeWithLeadingLowercase(property.name) %>(value));
  }

<% } -%>
<% } -%>


  /**
   * Inner class for transforming map click events into symbol clicks
   */
  private class MapClickResolver implements MapboxMap.OnMapClickListener {

    private MapboxMap mapboxMap;

    private MapClickResolver(MapboxMap mapboxMap) {
      this.mapboxMap = mapboxMap;
    }

    @Override
    public void onMapClick(@NonNull LatLng point) {
      if (symbolClickListener == null) {
        return;
      }

      PointF screenLocation = mapboxMap.getProjection().toScreenLocation(point);
      List<Feature> features = mapboxMap.queryRenderedFeatures(screenLocation, ID_GEOJSON_LAYER);
      if (!features.isEmpty()) {
        long symbolId = features.get(0).getProperty(Symbol.ID_KEY).getAsLong();
        Symbol symbol = symbols.get(symbolId);
        if (symbol != null) {
          symbolClickListener.onSymbolClick(symbols.get(symbolId));
        }
      }
    }
  }

}
